#include <iostream>

using namespace std;

void HuoDongAnPai(int* s, int* f, int n, bool* ans) {
	for (int i = 1; i <= n; i++)
		ans[i] = false;
	int curi = 1;//先选择活动1
	ans[curi] = true;

	for (int i = 2; i <= n; i++) {
		if (s[i] >= f[curi]) {
			//可以安排
			ans[i] = true;
			curi = i;
		}
	}
}

void BeiBao(int* w, int* v, int c, int n, float* ans) {
	//ans[i]表示i物品放入多少
	for (int i = 1; i <= n; i++) {
		if (c == 0) {
			break;
		}
		else if (c >= w[i]) {
			c -= w[i];
			ans[i] = w[i];
		}
		else {//放不完了，放一部分
			ans[i] = c;
			c = 0;
		}
	}
}

//int main() {
	/*
	贪心
	对于主问题，做出最优的选择，并递归解由此产生的子问题，最终得到的是整体最优解
	对比dp
	dp是将最优子问题的结果合并后形成主问题的最优解（自底向上）
	贪心是主问题选最优解，再解决由此产生的子问题（自顶向下）
	证明方法
	一般用归纳法证明可用贪心
	*/

	/*
	活动安排问题
	n个活动H，第i个活动的开始结束时间为s[i]、f[i]。在所给的活动集合中选出最大的相容活动子集合，即不重合的活动集合
	解法
	按结束时间升序排序，每次选择可以相容的下一个活动
	解题思路
	1	贪心算法用于此问题时，第一步必将选择活动H[1]
		所以先证有最优解是由H[1]开始的
	2	设A为一最优解，若包含H[1]，则成立，否则用H[1]替换A中首元素（必然可替换），则也成立
	3	则可以先选择H[1]，则得到了子问题H[2...n]
	1	按照结束时间排序的话，主问题是H[1...n]，子问题是H[2...n]
	2	所以归纳法要从首元素下标是1的情况开始，每次减少首元素
		命题
		设n个活动用按结束时间算法贪心能得到最优解
		n=1时，显然可以
		n=k时，设“用此算法”可以得到最优解A，A是H[k...n]的子集，则A中必然包含H[k]（贪心算法每一步都选择首元素）
		n=k+1时
			设此时序列的最优解是B（理论上，而不是说这个解是贪心来的，目的是证可以由贪心获得此解）
			若B中包含H[k+1]，则B就是可由贪心解得
			若B中不含H[K+1]，则可以将B的首元素替换为H[K+1]，得到B'，显然B'也是最优解，并且从H[K+1]开始
				所以它也是n=k+1时的最优解
	

	int n = 11;
	int s[12] = { -1,1,3,0,5,3,5,6,8,8,2,12 };
	int f[12] = { -1,4,5,6,7,8,9,10,11,12,13,14 };//升序已排好
	bool ans[12];
	HuoDongAnPai(s, f, n, ans);
	for (int i = 1; i <= n; i++)
		cout << ans[i] << " ";
	cout << endl;
	*/

	/*
	背包问题
	与01背包区别就是可以选择一部分装入
	解法
	1	可用贪心
	2	每次选择单位价值最高的物品尽可能多地放进袋子
	证明
		命题为背包问题由贪心算法得到的解是最优解
		是用数学归纳法
		n=1时，按照贪心算法得到的解是将这个物品放入背包，或者放满或者背包为空，但这显然是最优解。
		所以此时命题成立。
		假设n=k时由贪心算法得到的解是最优解。
		n=k+1时，将物品按单位重量价格降序排列。由上，对于前k个物品，按照贪心算法得得到的是最优解。
		此时背包如果满了，那么这种装法就是全局最优解，因为如果从背包拿出一点并放入k+1物品时，
		显然背包总价值变少。
		此时背包如果没满，则前k个物品应该是全部放进去了，此时再应用贪心算法（即n=1时的情况），
		可以得到全局最优解。
		综上，背包问题由贪心算法得到的解是最优解

	int n = 3, c = 5;
	int w[4] = { -1,1,2,3 }, v[4] = { -1,3,4,5 };//按v[i]/w[i]降序排序了
	float ans[4];
	BeiBao(w, v, c, n, ans);
	for (int i = 1; i <= n; i++)
		cout << ans[i] << " ";
	cout << endl;
	*/
//}